// prisma/schema.prisma
// DictateMED MVP Database Schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============ Organization & Users ============

model Practice {
  id         String   @id @default(uuid())
  name       String
  settings   Json     @default("{}")
  letterhead String? // S3 key for letterhead image
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  users    User[]
  patients Patient[]

  @@map("practices")
}

model User {
  id           String    @id @default(uuid())
  auth0Id      String    @unique
  email        String    @unique
  name         String
  role         UserRole  @default(SPECIALIST)
  signature    String? // S3 key for signature image
  styleProfile Json      @default("{}") // Learned style preferences
  settings     Json      @default("{}")
  practiceId   String
  practice     Practice  @relation(fields: [practiceId], references: [id])
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt
  lastLoginAt  DateTime?

  // Subspecialty interests for template recommendations
  subspecialties String[] @default([]) // Array of Subspecialty enum values

  recordings          Recording[]
  documents           Document[]
  letters             Letter[]
  auditLogs           AuditLog[]
  notifications       Notification[]
  styleEdits          StyleEdit[]
  templatePreferences UserTemplatePreference[]

  @@map("users")
}

enum UserRole {
  ADMIN
  SPECIALIST
}

// ============ Patients ============

model Patient {
  id            String   @id @default(uuid())
  // PHI stored encrypted via AES-256-GCM, minimal data
  encryptedData String // Encrypted JSON: name, dob, medicare, etc.
  practiceId    String
  practice      Practice @relation(fields: [practiceId], references: [id])
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  recordings Recording[]
  documents  Document[]
  letters    Letter[]

  @@index([practiceId])
  @@map("patients")
}

// ============ Recordings ============

model Recording {
  id        String    @id @default(uuid())
  userId    String
  user      User      @relation(fields: [userId], references: [id])
  patientId String?
  patient   Patient?  @relation(fields: [patientId], references: [id])

  mode   RecordingMode
  status RecordingStatus @default(UPLOADING)

  // Audio metadata
  durationSeconds Int?
  audioQuality    String? // excellent/good/fair/poor
  s3AudioKey      String?

  // Consent
  consentType ConsentType?
  consentAt   DateTime?

  // Transcription
  transcriptRaw  Json?   // Full Deepgram response
  transcriptText String? // Plain text transcript
  speakers       Json?   // Speaker diarization data

  // Processing
  processingError String?
  processedAt     DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  letters Letter[]

  @@index([userId, createdAt])
  @@map("recordings")
}

enum RecordingMode {
  AMBIENT
  DICTATION
}

enum RecordingStatus {
  UPLOADING
  UPLOADED
  TRANSCRIBING
  TRANSCRIBED
  FAILED
}

enum ConsentType {
  VERBAL
  WRITTEN
  STANDING
}

// ============ Documents ============

model Document {
  id        String   @id @default(uuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id])
  patientId String?
  patient   Patient? @relation(fields: [patientId], references: [id])

  filename  String
  mimeType  String
  sizeBytes Int
  s3Key     String

  documentType DocumentType?
  status       DocumentStatus @default(UPLOADING)

  // Extraction results
  extractedData   Json?   // Structured clinical data
  extractedText   String? // OCR/parsed text
  processingError String?
  processedAt     DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  letterDocuments LetterDocument[]

  @@index([userId, createdAt])
  @@map("documents")
}

enum DocumentType {
  ECHO_REPORT
  ANGIOGRAM_REPORT
  ECG_REPORT
  HOLTER_REPORT
  LAB_RESULT
  REFERRAL_LETTER
  OTHER
}

enum DocumentStatus {
  UPLOADING
  UPLOADED
  PROCESSING
  PROCESSED
  FAILED
}

// ============ Letters ============

model Letter {
  id          String     @id @default(uuid())
  userId      String
  user        User       @relation(fields: [userId], references: [id])
  patientId   String?
  patient     Patient?   @relation(fields: [patientId], references: [id])
  recordingId String?
  recording   Recording? @relation(fields: [recordingId], references: [id])

  // Template reference (optional - letters can still use basic letterType)
  templateId String?
  template   LetterTemplate? @relation(fields: [templateId], references: [id])

  letterType LetterType
  status     LetterStatus @default(GENERATING)

  // Content
  contentDraft String? @db.Text // Initial AI-generated content
  contentFinal String? @db.Text // After physician edits (approved content)
  contentDiff  Json?   // Diff between draft and final

  // Source anchoring
  sourceAnchors Json? // Map of text segments to sources

  // Clinical safety
  extractedValues      Json?  // LVEF, stenosis, etc. (ClinicalValue[])
  verifiedValues       Json?  // Which values physician confirmed
  hallucinationFlags   Json?  // Critic model findings (HallucinationFlag[])
  clinicalConcepts     Json?  // Diagnoses, meds, procedures (ClinicalConcepts)
  verificationRate     Float? // Percentage of values with source anchors
  hallucinationRiskScore Int? // Risk score 0-100

  // Model tracking
  primaryModel       String? // Model used for generation
  criticModel        String? // Model used for hallucination check
  styleConfidence    Float?  // 0-1 confidence in style match
  inputTokens        Int?    // Tokens consumed for input
  outputTokens       Int?    // Tokens generated for output
  generationDurationMs Int?  // Time taken for generation

  // Device locking for offline sync
  lockedByDeviceId String?
  lockedAt         DateTime?

  // Timing
  generatedAt      DateTime?
  reviewStartedAt  DateTime?
  approvedAt       DateTime?
  approvedBy       String?   // User ID who approved
  reviewDurationMs Int?      // Time spent reviewing

  // Processing
  processingError String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  documents  LetterDocument[]
  provenance Provenance?
  styleEdits StyleEdit[]

  @@index([userId, createdAt])
  @@index([status])
  @@map("letters")
}

enum LetterType {
  NEW_PATIENT
  FOLLOW_UP
  ANGIOGRAM_PROCEDURE
  ECHO_REPORT
}

enum LetterStatus {
  GENERATING
  DRAFT
  IN_REVIEW
  APPROVED
  FAILED
}

model LetterDocument {
  id         String   @id @default(uuid())
  letterId   String
  letter     Letter   @relation(fields: [letterId], references: [id], onDelete: Cascade)
  documentId String
  document   Document @relation(fields: [documentId], references: [id])

  @@unique([letterId, documentId])
  @@map("letter_documents")
}

// ============ Provenance & Audit ============

model Provenance {
  id       String @id @default(uuid())
  letterId String @unique
  letter   Letter @relation(fields: [letterId], references: [id], onDelete: Cascade)

  // Complete audit trail as structured JSON
  data Json

  // Cryptographic hash for tamper detection
  hash String

  createdAt DateTime @default(now())

  @@map("provenance")
}

model AuditLog {
  id           String   @id @default(uuid())
  userId       String?
  user         User?    @relation(fields: [userId], references: [id])
  action       String // login, logout, letter.create, letter.approve, etc.
  resourceType String? // letter, recording, document
  resourceId   String?
  metadata     Json     @default("{}")
  ipAddress    String?
  userAgent    String?
  createdAt    DateTime @default(now())

  @@index([userId, createdAt])
  @@index([action, createdAt])
  @@map("audit_logs")
}

// ============ Notifications ============

model Notification {
  id        String           @id @default(uuid())
  userId    String
  user      User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  type      NotificationType
  title     String
  message   String           @db.Text
  read      Boolean          @default(false)
  data      Json?            // Additional context data (letterId, recordingId, etc.)
  createdAt DateTime         @default(now())

  @@index([userId, createdAt])
  @@index([userId, read])
  @@map("notifications")
}

enum NotificationType {
  LETTER_READY
  TRANSCRIPTION_COMPLETE
  DOCUMENT_PROCESSED
  REVIEW_REMINDER
  SYSTEM
}

// ============ Style Learning ============

model StyleEdit {
  id        String   @id @default(uuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  letterId  String
  letter    Letter   @relation(fields: [letterId], references: [id], onDelete: Cascade)

  // Edit content
  beforeText String @db.Text // Original AI-generated text
  afterText  String @db.Text // Physician-edited text

  // Edit metadata
  editType         String // addition, deletion, modification, formatting
  sectionType      String? // greeting, history, examination, impression, plan, closing, other
  characterChanges Int // Total chars added/removed
  wordChanges      Int // Total words added/removed

  createdAt DateTime @default(now())

  @@index([userId, createdAt])
  @@index([letterId])
  @@map("style_edits")
}

// ============ Letter Templates ============

// Subspecialty categories for cardiology
enum Subspecialty {
  GENERAL_CARDIOLOGY
  INTERVENTIONAL
  STRUCTURAL
  ELECTROPHYSIOLOGY
  IMAGING
  HEART_FAILURE
  CARDIAC_SURGERY
}

// Template category for grouping
enum TemplateCategory {
  CONSULTATION
  PROCEDURE
  DIAGNOSTIC
  FOLLOW_UP
  DISCHARGE
}

// Letter templates with subspecialty tagging
model LetterTemplate {
  id          String   @id @default(uuid())
  name        String   // e.g., "New Patient Consultation"
  description String?  // Brief description of when to use
  slug        String   @unique // URL-friendly identifier

  // Categorization
  category       TemplateCategory
  subspecialties Subspecialty[] // Which subspecialties this applies to
  isGeneric      Boolean        @default(false) // Available to all subspecialties

  // Parent template for variants (e.g., "TTE Report" is parent of "Stress Echo Report")
  parentId String?
  parent   LetterTemplate?  @relation("TemplateVariants", fields: [parentId], references: [id])
  variants LetterTemplate[] @relation("TemplateVariants")

  // Template content
  promptTemplate   String  @db.Text // System prompt additions for this template
  sectionOrder     String[] // Default section order for this template
  requiredSections String[] // Sections that must be included
  optionalSections String[] // Sections that can be added

  // Sample/example content for UI preview
  sampleContent String? @db.Text

  // Metadata
  isActive  Boolean  @default(true)
  sortOrder Int      @default(0) // For display ordering
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  letters         Letter[]
  userPreferences UserTemplatePreference[]

  @@index([category])
  @@index([isGeneric])
  @@map("letter_templates")
}

// User preferences for templates (favorites, per-template style overrides)
model UserTemplatePreference {
  id         String         @id @default(uuid())
  userId     String
  user       User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  templateId String
  template   LetterTemplate @relation(fields: [templateId], references: [id], onDelete: Cascade)

  // Preference flags
  isFavorite Boolean @default(false)
  usageCount Int     @default(0) // Track usage for recommendations

  // Per-template style overrides (extends global styleProfile)
  styleOverrides Json @default("{}") // Partial StyleProfile overrides

  // Last used for recency-based recommendations
  lastUsedAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userId, templateId])
  @@index([userId, isFavorite])
  @@map("user_template_preferences")
}

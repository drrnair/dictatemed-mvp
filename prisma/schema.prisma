// prisma/schema.prisma
// DictateMED MVP Database Schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============ Organization & Users ============

model Practice {
  id         String   @id @default(uuid())
  name       String
  settings   Json     @default("{}")
  letterhead String? // S3 key for letterhead image
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  users     User[]
  patients  Patient[]
  referrers Referrer[]

  @@map("practices")
}

model User {
  id           String    @id @default(uuid())
  auth0Id      String    @unique
  email        String    @unique
  name         String
  role         UserRole  @default(SPECIALIST)
  signature    String? // S3 key for signature image
  styleProfile Json      @default("{}") // Learned style preferences
  settings     Json      @default("{}")
  practiceId   String
  practice     Practice  @relation(fields: [practiceId], references: [id])
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt
  lastLoginAt  DateTime?

  // Clinician role for specialty-based onboarding (Medical, Nursing, Allied Health)
  clinicianRole ClinicianRole @default(MEDICAL)

  // Legacy: Subspecialty interests for template recommendations (being replaced by ClinicianSubspecialty)
  subspecialties String[] @default([]) // Array of Subspecialty enum values

  recordings          Recording[]
  documents           Document[]
  letters             Letter[]
  consultations       Consultation[]
  auditLogs           AuditLog[]
  notifications       Notification[]
  styleEdits          StyleEdit[]
  templatePreferences UserTemplatePreference[]
  letterSends         LetterSend[]

  // Per-subspecialty style learning
  styleProfiles    StyleProfile[]
  styleSeedLetters StyleSeedLetter[]

  // Medical specialty selections
  clinicianSpecialties    ClinicianSpecialty[]
  clinicianSubspecialties ClinicianSubspecialty[]
  customSpecialties       CustomSpecialty[]
  customSubspecialties    CustomSubspecialty[]

  @@map("users")
}

enum UserRole {
  ADMIN
  SPECIALIST
}

// Clinician role for specialty-based onboarding
enum ClinicianRole {
  MEDICAL
  NURSING
  ALLIED_HEALTH
}

// Status for custom specialty/subspecialty requests
enum CustomRequestStatus {
  PENDING
  APPROVED
  REJECTED
}

// ============ Patients ============

model Patient {
  id            String   @id @default(uuid())
  // PHI stored encrypted via AES-256-GCM, minimal data
  encryptedData String // Encrypted JSON: name, dob, medicare, etc.
  practiceId    String
  practice      Practice @relation(fields: [practiceId], references: [id])
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  recordings    Recording[]
  documents     Document[]
  letters       Letter[]
  consultations Consultation[]
  contacts      PatientContact[]
  letterSends   LetterSend[]

  @@index([practiceId])
  @@map("patients")
}

// ============ Recordings ============

model Recording {
  id        String   @id @default(uuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id])
  patientId String?
  patient   Patient? @relation(fields: [patientId], references: [id])

  // Link to consultation context
  consultationId String?
  consultation   Consultation? @relation(fields: [consultationId], references: [id])

  mode   RecordingMode
  status RecordingStatus @default(UPLOADING)

  // Audio metadata
  durationSeconds Int?
  audioQuality    String? // excellent/good/fair/poor
  s3AudioKey      String?

  // Consent
  consentType ConsentType?
  consentAt   DateTime?

  // Transcription
  transcriptRaw  Json? // Full Deepgram response
  transcriptText String? // Plain text transcript
  speakers       Json? // Speaker diarization data

  // Processing
  processingError String?
  processedAt     DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  letters Letter[]

  @@index([userId, createdAt])
  @@map("recordings")
}

enum RecordingMode {
  AMBIENT
  DICTATION
}

enum RecordingStatus {
  UPLOADING
  UPLOADED
  TRANSCRIBING
  TRANSCRIBED
  FAILED
}

enum ConsentType {
  VERBAL
  WRITTEN
  STANDING
}

// ============ Documents ============

model Document {
  id        String   @id @default(uuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id])
  patientId String?
  patient   Patient? @relation(fields: [patientId], references: [id])

  // Link to consultation context (for documents uploaded during a consultation)
  consultationId String?
  consultation   Consultation? @relation(fields: [consultationId], references: [id])

  filename  String
  mimeType  String
  sizeBytes Int
  s3Key     String

  documentType DocumentType?
  status       DocumentStatus @default(UPLOADING)

  // Extraction results
  extractedData   Json? // Structured clinical data
  extractedText   String? // OCR/parsed text
  processingError String?
  processedAt     DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  letterDocuments LetterDocument[]

  @@index([userId, createdAt])
  @@map("documents")
}

enum DocumentType {
  ECHO_REPORT
  ANGIOGRAM_REPORT
  ECG_REPORT
  HOLTER_REPORT
  LAB_RESULT
  REFERRAL_LETTER
  OTHER
}

enum DocumentStatus {
  UPLOADING
  UPLOADED
  PROCESSING
  PROCESSED
  FAILED
}

// ============ Letters ============

model Letter {
  id          String     @id @default(uuid())
  userId      String
  user        User       @relation(fields: [userId], references: [id])
  patientId   String?
  patient     Patient?   @relation(fields: [patientId], references: [id])
  recordingId String?
  recording   Recording? @relation(fields: [recordingId], references: [id])

  // Link to consultation context
  consultationId String?
  consultation   Consultation? @relation(fields: [consultationId], references: [id])

  // Template reference (optional - letters can still use basic letterType)
  templateId String?
  template   LetterTemplate? @relation(fields: [templateId], references: [id])

  letterType   LetterType
  status       LetterStatus  @default(GENERATING)
  subspecialty Subspecialty? // Inferred or explicit subspecialty for style learning

  // Content
  contentDraft String? @db.Text // Initial AI-generated content
  contentFinal String? @db.Text // After physician edits (approved content)
  contentDiff  Json? // Diff between draft and final

  // Source anchoring
  sourceAnchors Json? // Map of text segments to sources

  // Clinical safety
  extractedValues        Json? // LVEF, stenosis, etc. (ClinicalValue[])
  verifiedValues         Json? // Which values physician confirmed
  hallucinationFlags     Json? // Critic model findings (HallucinationFlag[])
  clinicalConcepts       Json? // Diagnoses, meds, procedures (ClinicalConcepts)
  verificationRate       Float? // Percentage of values with source anchors
  hallucinationRiskScore Int? // Risk score 0-100

  // Model tracking
  primaryModel         String? // Model used for generation
  criticModel          String? // Model used for hallucination check
  styleConfidence      Float? // 0-1 confidence in style match
  inputTokens          Int? // Tokens consumed for input
  outputTokens         Int? // Tokens generated for output
  generationDurationMs Int? // Time taken for generation

  // Device locking for offline sync
  lockedByDeviceId String?
  lockedAt         DateTime?

  // Timing
  generatedAt      DateTime?
  reviewStartedAt  DateTime?
  approvedAt       DateTime?
  approvedBy       String? // User ID who approved
  reviewDurationMs Int? // Time spent reviewing

  // Processing
  processingError String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  documents  LetterDocument[]
  provenance Provenance?
  styleEdits StyleEdit[]
  sends      LetterSend[]

  @@index([userId, createdAt])
  @@index([status])
  @@map("letters")
}

enum LetterType {
  NEW_PATIENT
  FOLLOW_UP
  ANGIOGRAM_PROCEDURE
  ECHO_REPORT
}

enum LetterStatus {
  GENERATING
  DRAFT
  IN_REVIEW
  APPROVED
  FAILED
}

model LetterDocument {
  id         String   @id @default(uuid())
  letterId   String
  letter     Letter   @relation(fields: [letterId], references: [id], onDelete: Cascade)
  documentId String
  document   Document @relation(fields: [documentId], references: [id])

  @@unique([letterId, documentId])
  @@map("letter_documents")
}

// ============ Provenance & Audit ============

model Provenance {
  id       String @id @default(uuid())
  letterId String @unique
  letter   Letter @relation(fields: [letterId], references: [id], onDelete: Cascade)

  // Complete audit trail as structured JSON
  data Json

  // Cryptographic hash for tamper detection
  hash String

  createdAt DateTime @default(now())

  @@map("provenance")
}

model AuditLog {
  id           String   @id @default(uuid())
  userId       String?
  user         User?    @relation(fields: [userId], references: [id])
  action       String // login, logout, letter.create, letter.approve, etc.
  resourceType String? // letter, recording, document
  resourceId   String?
  metadata     Json     @default("{}")
  ipAddress    String?
  userAgent    String?
  createdAt    DateTime @default(now())

  @@index([userId, createdAt])
  @@index([action, createdAt])
  @@map("audit_logs")
}

// ============ Notifications ============

model Notification {
  id        String           @id @default(uuid())
  userId    String
  user      User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  type      NotificationType
  title     String
  message   String           @db.Text
  read      Boolean          @default(false)
  data      Json? // Additional context data (letterId, recordingId, etc.)
  createdAt DateTime         @default(now())

  @@index([userId, createdAt])
  @@index([userId, read])
  @@map("notifications")
}

enum NotificationType {
  LETTER_READY
  TRANSCRIPTION_COMPLETE
  DOCUMENT_PROCESSED
  REVIEW_REMINDER
  SYSTEM
}

// ============ Style Learning ============

model StyleEdit {
  id       String @id @default(uuid())
  userId   String
  user     User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  letterId String
  letter   Letter @relation(fields: [letterId], references: [id], onDelete: Cascade)

  // Edit content
  beforeText String @db.Text // Original AI-generated text
  afterText  String @db.Text // Physician-edited text

  // Edit metadata
  editType         String // addition, deletion, modification, formatting
  sectionType      String? // greeting, history, examination, impression, plan, closing, other
  characterChanges Int // Total chars added/removed
  wordChanges      Int // Total words added/removed

  // Subspecialty context for per-subspecialty learning
  subspecialty Subspecialty?

  createdAt DateTime @default(now())

  @@index([userId, createdAt])
  @@index([letterId])
  @@index([userId, subspecialty])
  @@map("style_edits")
}

// Per-clinician, per-subspecialty style profile
model StyleProfile {
  id           String       @id @default(uuid())
  userId       String
  user         User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  subspecialty Subspecialty

  // Section preferences
  sectionOrder     String[] // e.g., ["History", "Examination", "Impression", "Plan"]
  sectionInclusion Json     @default("{}") // { "Medications": 0.9, "FamilyHistory": 0.3 }
  sectionVerbosity Json     @default("{}") // { "History": "detailed", "Plan": "brief" }

  // Phrasing preferences
  phrasingPreferences Json    @default("{}") // Common phrases per section
  avoidedPhrases      Json    @default("{}") // Phrases consistently deleted
  vocabularyMap       Json    @default("{}") // { "utilize": "use" }
  terminologyLevel    String? // "specialist" | "lay" | "mixed"

  // Global style indicators
  greetingStyle      String? // "formal" | "casual" | "mixed"
  closingStyle       String? // "formal" | "casual" | "mixed"
  signoffTemplate    String? // Preferred sign-off text
  formalityLevel     String? // "very-formal" | "formal" | "neutral" | "casual"
  paragraphStructure String? // "long" | "short" | "mixed"

  // Confidence & metadata
  confidence         Json      @default("{}") // Per-preference confidence scores
  learningStrength   Float     @default(1.0) // 0.0 = disabled, 1.0 = full effect
  totalEditsAnalyzed Int       @default(0)
  lastAnalyzedAt     DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userId, subspecialty])
  @@index([userId])
  @@map("style_profiles")
}

// Seed letters for bootstrapping style profiles
model StyleSeedLetter {
  id           String       @id @default(uuid())
  userId       String
  user         User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  subspecialty Subspecialty

  letterText String    @db.Text
  analyzedAt DateTime?

  createdAt DateTime @default(now())

  @@index([userId, subspecialty])
  @@map("style_seed_letters")
}

// Internal aggregated analytics (de-identified)
model StyleAnalyticsAggregate {
  id           String       @id @default(uuid())
  subspecialty Subspecialty
  period       String // e.g., "2024-W01" (weekly)

  // Aggregated patterns (no PHI, no clinician IDs)
  commonAdditions      Json // Frequently added sections/phrases
  commonDeletions      Json // Frequently deleted content
  sectionOrderPatterns Json // Common section arrangements
  phrasingPatterns     Json // High-frequency phrase patterns
  sampleSize           Int // Number of letters contributing

  createdAt DateTime @default(now())

  @@unique([subspecialty, period])
  @@map("style_analytics_aggregates")
}

// ============ Medical Specialties Taxonomy ============

// Global medical specialties (seeded from ABMS, AHPRA, etc.)
model MedicalSpecialty {
  id          String   @id @default(uuid())
  name        String   @unique // e.g., "Cardiology"
  slug        String   @unique // e.g., "cardiology"
  description String?  @db.Text
  synonyms    Json     @default("[]") // e.g., ["cardiologist", "cardiac medicine"]
  active      Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  subspecialties       MedicalSubspecialty[]
  clinicianSpecialties ClinicianSpecialty[]
  customSubspecialties CustomSubspecialty[]

  @@index([active])
  @@map("medical_specialties")
}

// Subspecialties within a medical specialty
model MedicalSubspecialty {
  id          String           @id @default(uuid())
  specialtyId String
  specialty   MedicalSpecialty @relation(fields: [specialtyId], references: [id], onDelete: Cascade)
  name        String // e.g., "Interventional cardiology"
  slug        String // e.g., "interventional-cardiology"
  description String?          @db.Text
  active      Boolean          @default(true)
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt

  // Relations
  clinicianSubspecialties ClinicianSubspecialty[]

  @@unique([specialtyId, slug])
  @@index([specialtyId])
  @@index([active])
  @@map("medical_subspecialties")
}

// Junction table: User's selected specialties
model ClinicianSpecialty {
  id          String           @id @default(uuid())
  userId      String
  user        User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  specialtyId String
  specialty   MedicalSpecialty @relation(fields: [specialtyId], references: [id], onDelete: Cascade)
  createdAt   DateTime         @default(now())

  @@unique([userId, specialtyId])
  @@index([userId])
  @@index([specialtyId])
  @@map("clinician_specialties")
}

// Junction table: User's selected subspecialties
model ClinicianSubspecialty {
  id             String              @id @default(uuid())
  userId         String
  user           User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  subspecialtyId String
  subspecialty   MedicalSubspecialty @relation(fields: [subspecialtyId], references: [id], onDelete: Cascade)
  createdAt      DateTime            @default(now())

  @@unique([userId, subspecialtyId])
  @@index([userId])
  @@index([subspecialtyId])
  @@map("clinician_subspecialties")
}

// Custom specialty requests from clinicians (pending admin review)
model CustomSpecialty {
  id        String              @id @default(uuid())
  userId    String
  user      User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  name      String
  region    String? // e.g., "AU", "US" for regional specialties
  notes     String?             @db.Text
  status    CustomRequestStatus @default(PENDING)
  createdAt DateTime            @default(now())
  updatedAt DateTime            @updatedAt

  // If approved, link to the created MedicalSpecialty
  approvedSpecialtyId String?

  // Custom subspecialties linked to this custom specialty
  customSubspecialties CustomSubspecialty[]

  @@index([userId])
  @@index([status])
  @@map("custom_specialties")
}

// Custom subspecialty requests from clinicians (pending admin review)
model CustomSubspecialty {
  id          String              @id @default(uuid())
  userId      String
  user        User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  name        String
  description String?             @db.Text
  status      CustomRequestStatus @default(PENDING)
  createdAt   DateTime            @default(now())
  updatedAt   DateTime            @updatedAt

  // Can be linked to either a global specialty or a custom specialty
  specialtyId       String?
  specialty         MedicalSpecialty? @relation(fields: [specialtyId], references: [id], onDelete: Cascade)
  customSpecialtyId String?
  customSpecialty   CustomSpecialty?  @relation(fields: [customSpecialtyId], references: [id], onDelete: Cascade)

  // If approved, link to the created MedicalSubspecialty
  approvedSubspecialtyId String?

  @@index([userId])
  @@index([specialtyId])
  @@index([customSpecialtyId])
  @@index([status])
  @@map("custom_subspecialties")
}

// ============ Letter Templates ============

// Subspecialty categories for cardiology
enum Subspecialty {
  GENERAL_CARDIOLOGY
  INTERVENTIONAL
  STRUCTURAL
  ELECTROPHYSIOLOGY
  IMAGING
  HEART_FAILURE
  CARDIAC_SURGERY
}

// Template category for grouping
enum TemplateCategory {
  CONSULTATION
  PROCEDURE
  DIAGNOSTIC
  FOLLOW_UP
  DISCHARGE
}

// Letter templates with subspecialty tagging
model LetterTemplate {
  id          String  @id @default(uuid())
  name        String // e.g., "New Patient Consultation"
  description String? // Brief description of when to use
  slug        String  @unique // URL-friendly identifier

  // Categorization
  category       TemplateCategory
  subspecialties Subspecialty[] // Which subspecialties this applies to
  isGeneric      Boolean          @default(false) // Available to all subspecialties

  // Parent template for variants (e.g., "TTE Report" is parent of "Stress Echo Report")
  parentId String?
  parent   LetterTemplate?  @relation("TemplateVariants", fields: [parentId], references: [id])
  variants LetterTemplate[] @relation("TemplateVariants")

  // Template content
  promptTemplate   String   @db.Text // System prompt additions for this template
  sectionOrder     String[] // Default section order for this template
  requiredSections String[] // Sections that must be included
  optionalSections String[] // Sections that can be added

  // Sample/example content for UI preview
  sampleContent String? @db.Text

  // Metadata
  isActive  Boolean  @default(true)
  sortOrder Int      @default(0) // For display ordering
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  letters         Letter[]
  userPreferences UserTemplatePreference[]
  consultations   Consultation[]

  @@index([category])
  @@index([isGeneric])
  @@map("letter_templates")
}

// User preferences for templates (favorites, per-template style overrides)
model UserTemplatePreference {
  id         String         @id @default(uuid())
  userId     String
  user       User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  templateId String
  template   LetterTemplate @relation(fields: [templateId], references: [id], onDelete: Cascade)

  // Preference flags
  isFavorite Boolean @default(false)
  usageCount Int     @default(0) // Track usage for recommendations

  // Per-template style overrides (extends global styleProfile)
  styleOverrides Json @default("{}") // Partial StyleProfile overrides

  // Last used for recency-based recommendations
  lastUsedAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userId, templateId])
  @@index([userId, isFavorite])
  @@map("user_template_preferences")
}

// ============ Consultation Context ============

// Referrer/GP information (reusable across consultations within a practice)
model Referrer {
  id         String   @id @default(uuid())
  practiceId String
  practice   Practice @relation(fields: [practiceId], references: [id])

  name         String // Dr. John Smith
  practiceName String? // Sydney Medical Centre
  email        String?
  phone        String?
  fax          String?
  address      String? @db.Text // Postal address

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  consultations Consultation[]

  @@index([practiceId])
  @@index([practiceId, name])
  @@map("referrers")
}

// CC Recipients for a specific consultation
model CCRecipient {
  id             String       @id @default(uuid())
  consultationId String
  consultation   Consultation @relation(fields: [consultationId], references: [id], onDelete: Cascade)

  name    String
  email   String?
  address String? @db.Text // Postal address

  createdAt DateTime @default(now())

  @@index([consultationId])
  @@map("cc_recipients")
}

// Consultation context - bundles patient, referrer, recording, and selected materials
model Consultation {
  id     String @id @default(uuid())
  userId String
  user   User   @relation(fields: [userId], references: [id])

  // Patient for this consultation
  patientId String?
  patient   Patient? @relation(fields: [patientId], references: [id])

  // Referrer/GP for this consultation
  referrerId String?
  referrer   Referrer? @relation(fields: [referrerId], references: [id])

  // Letter type pre-selection
  templateId String?
  template   LetterTemplate? @relation(fields: [templateId], references: [id])
  letterType LetterType?

  // Selected context materials (IDs of existing letters/documents to use as context)
  selectedLetterIds   String[] @default([])
  selectedDocumentIds String[] @default([])

  // Status tracking
  status ConsultationStatus @default(DRAFT)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  ccRecipients CCRecipient[]
  recordings   Recording[]
  documents    Document[] // Documents uploaded during this consultation
  letters      Letter[] // Generated letters from this consultation

  @@index([userId, createdAt])
  @@index([patientId])
  @@index([status])
  @@map("consultations")
}

enum ConsultationStatus {
  DRAFT // Context being gathered
  RECORDING // Recording in progress
  PROCESSING // Transcription/processing in progress
  READY // Ready for letter generation
  COMPLETED // Letter generated
}

// ============ Patient Contacts & Letter Sending ============

enum ContactType {
  GP
  REFERRER
  SPECIALIST
  OTHER
}

enum ChannelType {
  EMAIL
  SECURE_MESSAGING
  FAX
  POST
}

enum SendStatus {
  QUEUED
  SENDING
  SENT
  FAILED
  BOUNCED
}

// Patient-linked contacts (GP, referrer, specialists, etc.)
model PatientContact {
  id        String  @id @default(uuid())
  patientId String
  patient   Patient @relation(fields: [patientId], references: [id], onDelete: Cascade)

  type         ContactType // GP, REFERRER, SPECIALIST, OTHER
  fullName     String
  organisation String? // Practice name
  role         String? // Specialty/role (free text)

  // Communication channels
  email             String?
  phone             String?
  fax               String?
  address           String?     @db.Text
  secureMessagingId String? // Future: HealthLink/FHIR
  preferredChannel  ChannelType @default(EMAIL)

  // Defaults
  isDefaultForPatient Boolean @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  letterSends LetterSend[]

  @@index([patientId])
  @@index([patientId, type])
  @@map("patient_contacts")
}

// Audit log for letter sends
model LetterSend {
  id       String @id @default(uuid())
  letterId String
  letter   Letter @relation(fields: [letterId], references: [id], onDelete: Cascade)

  // Denormalized patientId for direct audit queries (preserved even if letter deleted via cascade)
  patientId String?
  patient   Patient? @relation(fields: [patientId], references: [id], onDelete: SetNull)

  // Who sent
  senderId String
  sender   User   @relation(fields: [senderId], references: [id])

  // Recipient info
  patientContactId String? // Nullable for one-off recipients
  patientContact   PatientContact? @relation(fields: [patientContactId], references: [id])

  // Denormalized recipient info (for audit even if contact deleted)
  recipientName  String
  recipientEmail String
  recipientType  ContactType?

  // Send details
  channel   ChannelType @default(EMAIL)
  subject   String
  coverNote String?     @db.Text

  // Status tracking
  status       SendStatus @default(QUEUED)
  queuedAt     DateTime   @default(now())
  sentAt       DateTime?
  failedAt     DateTime?
  errorMessage String?

  // Email provider reference
  externalId String? // Provider message ID for tracking

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([letterId])
  @@index([patientId])
  @@index([senderId])
  @@index([status])
  @@map("letter_sends")
}

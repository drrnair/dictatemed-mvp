// prisma/schema.prisma
// DictateMED MVP Database Schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============ Organization & Users ============

model Practice {
  id         String   @id @default(uuid())
  name       String
  settings   Json     @default("{}")
  letterhead String? // S3 key for letterhead image
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  users             User[]
  patients          Patient[]
  referrers         Referrer[]
  referralDocuments ReferralDocument[]

  @@map("practices")
}

model User {
  id           String    @id @default(uuid())
  auth0Id      String    @unique
  email        String    @unique
  name         String
  role         UserRole  @default(SPECIALIST)
  signature    String? // S3 key for signature image
  styleProfile Json      @default("{}") // Learned style preferences
  settings     Json      @default("{}")
  practiceId   String
  practice     Practice  @relation(fields: [practiceId], references: [id])
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt
  lastLoginAt  DateTime?

  // Onboarding completion timestamp (set when user completes or skips onboarding)
  onboardingCompletedAt DateTime? @map("onboarding_completed_at")

  // Clinician role for specialty-based onboarding (Medical, Nursing, Allied Health)
  clinicianRole ClinicianRole @default(MEDICAL) @map("clinician_role")

  // Legacy: Subspecialty interests for template recommendations (being replaced by ClinicianSubspecialty)
  subspecialties String[] @default([]) // Array of Subspecialty enum values

  recordings          Recording[]
  documents           Document[]
  letters             Letter[]
  consultations       Consultation[]
  auditLogs           AuditLog[]
  notifications       Notification[]
  styleEdits          StyleEdit[]
  templatePreferences UserTemplatePreference[]
  sentEmails          SentEmail[]
  letterSends         LetterSend[]

  // Per-subspecialty style learning
  styleProfiles    StyleProfile[]
  styleSeedLetters StyleSeedLetter[]

  // Medical specialty selections
  clinicianSpecialties    ClinicianSpecialty[]
  clinicianSubspecialties ClinicianSubspecialty[]
  customSpecialties       CustomSpecialty[]
  customSubspecialties    CustomSubspecialty[]

  // Referral documents
  referralDocuments ReferralDocument[]

  @@map("users")
}

enum UserRole {
  ADMIN
  SPECIALIST
}

// Clinician role for specialty-based onboarding
enum ClinicianRole {
  MEDICAL
  NURSING
  ALLIED_HEALTH
}

// Status for custom specialty/subspecialty requests
enum CustomRequestStatus {
  PENDING
  APPROVED
  REJECTED
}

// ============ Patients ============

model Patient {
  id            String   @id @default(uuid())
  // PHI stored encrypted via AES-256-GCM, minimal data
  encryptedData String // Encrypted JSON: name, dob, medicare, etc.
  practiceId    String
  practice      Practice @relation(fields: [practiceId], references: [id])
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  recordings        Recording[]
  documents         Document[]
  letters           Letter[]
  consultations     Consultation[]
  contacts          PatientContact[]
  letterSends       LetterSend[]
  referralDocuments ReferralDocument[]

  @@index([practiceId])
  @@map("patients")
}

// ============ Recordings ============

model Recording {
  id        String   @id @default(uuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id])
  patientId String?
  patient   Patient? @relation(fields: [patientId], references: [id])

  // Link to consultation context
  consultationId String?
  consultation   Consultation? @relation(fields: [consultationId], references: [id])

  mode   RecordingMode
  status RecordingStatus @default(UPLOADING)

  // Audio metadata
  durationSeconds Int?
  fileSizeBytes   Int? // Size of uploaded audio file in bytes
  audioQuality    String? // excellent/good/fair/poor
  s3AudioKey      String? // @deprecated - use storagePath for Supabase Storage
  storagePath     String? // Supabase Storage path: {userId}/{consultationId}/{timestamp}_{mode}.{ext}
  audioDeletedAt  DateTime? // When audio was deleted from storage (retention policy)

  // Consent
  consentType ConsentType?
  consentAt   DateTime?

  // Transcription
  transcriptRaw  Json? // Full Deepgram response
  transcriptText String? // Plain text transcript
  speakers       Json? // Speaker diarization data

  // Processing
  processingError String?
  processedAt     DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  letters Letter[]

  @@index([userId, createdAt])
  @@map("recordings")
}

enum RecordingMode {
  AMBIENT
  DICTATION
}

enum RecordingStatus {
  UPLOADING
  UPLOADED
  TRANSCRIBING
  TRANSCRIBED
  FAILED
}

enum ConsentType {
  VERBAL
  WRITTEN
  STANDING
}

// ============ Documents ============

model Document {
  id        String   @id @default(uuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id])
  patientId String?
  patient   Patient? @relation(fields: [patientId], references: [id])

  // Link to consultation context (for documents uploaded during a consultation)
  consultationId String?
  consultation   Consultation? @relation(fields: [consultationId], references: [id])

  filename  String
  mimeType  String
  sizeBytes Int
  s3Key     String? // @deprecated - use storagePath for Supabase Storage
  storagePath String? // Supabase Storage path: {userId}/{patientId}/{docType}/{filename}_{timestamp}.{ext}

  documentType DocumentType?
  status       DocumentStatus @default(UPLOADING)

  // Retention and soft delete
  retentionUntil DateTime? // When the document should be deleted (retention policy)
  deletedAt      DateTime? // When the document was deleted from storage
  deletionReason String?   // Reason for deletion (retention_expired, user_requested, etc.)

  // Extraction results
  extractedData   Json? // Structured clinical data
  extractedText   String? // OCR/parsed text
  processingError String?
  processedAt     DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  letterDocuments LetterDocument[]

  @@index([userId, createdAt])
  @@index([retentionUntil]) // For retention cleanup job
  @@map("documents")
}

enum DocumentType {
  ECHO_REPORT
  ANGIOGRAM_REPORT
  ECG_REPORT
  HOLTER_REPORT
  LAB_RESULT
  REFERRAL_LETTER
  OTHER
}

enum DocumentStatus {
  UPLOADING
  UPLOADED
  PROCESSING
  PROCESSED
  FAILED
}

// ============ Letters ============

model Letter {
  id          String     @id @default(uuid())
  userId      String
  user        User       @relation(fields: [userId], references: [id])
  patientId   String?
  patient     Patient?   @relation(fields: [patientId], references: [id])
  recordingId String?
  recording   Recording? @relation(fields: [recordingId], references: [id])

  // Link to consultation context
  consultationId String?
  consultation   Consultation? @relation(fields: [consultationId], references: [id])

  // Template reference (optional - letters can still use basic letterType)
  templateId String?
  template   LetterTemplate? @relation(fields: [templateId], references: [id])

  letterType   LetterType
  status       LetterStatus  @default(GENERATING)
  subspecialty Subspecialty? // Inferred or explicit subspecialty for style learning

  // Content
  contentDraft String? @db.Text // Initial AI-generated content
  contentFinal String? @db.Text // After physician edits (approved content)
  contentDiff  Json? // Diff between draft and final

  // Source anchoring
  sourceAnchors Json? // Map of text segments to sources

  // Clinical safety
  extractedValues        Json? // LVEF, stenosis, etc. (ClinicalValue[])
  verifiedValues         Json? // Which values physician confirmed
  hallucinationFlags     Json? // Critic model findings (HallucinationFlag[])
  clinicalConcepts       Json? // Diagnoses, meds, procedures (ClinicalConcepts)
  verificationRate       Float? // Percentage of values with source anchors
  hallucinationRiskScore Int? // Risk score 0-100

  // Model tracking
  primaryModel         String? // Model used for generation
  criticModel          String? // Model used for hallucination check
  styleConfidence      Float? // 0-1 confidence in style match
  inputTokens          Int? // Tokens consumed for input
  outputTokens         Int? // Tokens generated for output
  generationDurationMs Int? // Time taken for generation

  // Device locking for offline sync
  lockedByDeviceId String?
  lockedAt         DateTime?

  // Timing
  generatedAt      DateTime?
  reviewStartedAt  DateTime?
  approvedAt       DateTime?
  approvedBy       String? // User ID who approved
  reviewDurationMs Int? // Time spent reviewing

  // Processing
  processingError String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  documents  LetterDocument[]
  provenance Provenance?
  styleEdits StyleEdit[]
  sentEmails SentEmail[]
  sends      LetterSend[]

  @@index([userId, createdAt])
  @@index([status])
  @@map("letters")
}

enum LetterType {
  NEW_PATIENT
  FOLLOW_UP
  ANGIOGRAM_PROCEDURE
  ECHO_REPORT
}

enum LetterStatus {
  GENERATING
  DRAFT
  IN_REVIEW
  APPROVED
  FAILED
}

model LetterDocument {
  id         String   @id @default(uuid())
  letterId   String
  letter     Letter   @relation(fields: [letterId], references: [id], onDelete: Cascade)
  documentId String
  document   Document @relation(fields: [documentId], references: [id])

  @@unique([letterId, documentId])
  @@map("letter_documents")
}

// ============ Provenance & Audit ============

model Provenance {
  id       String @id @default(uuid())
  letterId String @unique
  letter   Letter @relation(fields: [letterId], references: [id], onDelete: Cascade)

  // Complete audit trail as structured JSON
  data Json

  // Cryptographic hash for tamper detection
  hash String

  createdAt DateTime @default(now())

  @@map("provenance")
}

model AuditLog {
  id           String   @id @default(uuid())
  userId       String?
  user         User?    @relation(fields: [userId], references: [id])
  action       String // login, logout, letter.create, letter.approve, etc.
  resourceType String? // letter, recording, document
  resourceId   String?
  metadata     Json     @default("{}")
  ipAddress    String?
  userAgent    String?
  createdAt    DateTime @default(now())

  @@index([userId, createdAt])
  @@index([action, createdAt])
  @@map("audit_logs")
}

// ============ Notifications ============

model Notification {
  id        String           @id @default(uuid())
  userId    String
  user      User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  type      NotificationType
  title     String
  message   String           @db.Text
  read      Boolean          @default(false)
  data      Json? // Additional context data (letterId, recordingId, etc.)
  createdAt DateTime         @default(now())

  @@index([userId, createdAt])
  @@index([userId, read])
  @@map("notifications")
}

enum NotificationType {
  LETTER_READY
  TRANSCRIPTION_COMPLETE
  DOCUMENT_PROCESSED
  REVIEW_REMINDER
  SYSTEM
}

// ============ Style Learning ============

model StyleEdit {
  id       String @id @default(uuid())
  userId   String
  user     User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  letterId String
  letter   Letter @relation(fields: [letterId], references: [id], onDelete: Cascade)

  // Edit content
  beforeText String @db.Text // Original AI-generated text
  afterText  String @db.Text // Physician-edited text

  // Edit metadata
  editType         String // addition, deletion, modification, formatting
  sectionType      String? // greeting, history, examination, impression, plan, closing, other
  characterChanges Int // Total chars added/removed
  wordChanges      Int // Total words added/removed

  // Subspecialty context for per-subspecialty learning
  subspecialty Subspecialty?

  createdAt DateTime @default(now())

  @@index([userId, createdAt])
  @@index([letterId])
  @@index([userId, subspecialty])
  @@map("style_edits")
}

// Per-clinician, per-subspecialty style profile
model StyleProfile {
  id           String       @id @default(uuid())
  userId       String
  user         User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  subspecialty Subspecialty

  // Section preferences
  sectionOrder     String[] // e.g., ["History", "Examination", "Impression", "Plan"]
  sectionInclusion Json     @default("{}") // { "Medications": 0.9, "FamilyHistory": 0.3 }
  sectionVerbosity Json     @default("{}") // { "History": "detailed", "Plan": "brief" }

  // Phrasing preferences
  phrasingPreferences Json    @default("{}") // Common phrases per section
  avoidedPhrases      Json    @default("{}") // Phrases consistently deleted
  vocabularyMap       Json    @default("{}") // { "utilize": "use" }
  terminologyLevel    String? // "specialist" | "lay" | "mixed"

  // Global style indicators
  greetingStyle      String? // "formal" | "casual" | "mixed"
  closingStyle       String? // "formal" | "casual" | "mixed"
  signoffTemplate    String? // Preferred sign-off text
  formalityLevel     String? // "very-formal" | "formal" | "neutral" | "casual"
  paragraphStructure String? // "long" | "short" | "mixed"

  // Confidence & metadata
  confidence         Json      @default("{}") // Per-preference confidence scores
  learningStrength   Float     @default(1.0) // 0.0 = disabled, 1.0 = full effect
  totalEditsAnalyzed Int       @default(0)
  lastAnalyzedAt     DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userId, subspecialty])
  @@index([userId])
  @@map("style_profiles")
}

// Seed letters for bootstrapping style profiles
model StyleSeedLetter {
  id           String       @id @default(uuid())
  userId       String
  user         User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  subspecialty Subspecialty

  letterText String    @db.Text
  analyzedAt DateTime?

  createdAt DateTime @default(now())

  @@index([userId, subspecialty])
  @@map("style_seed_letters")
}

// Internal aggregated analytics (de-identified)
model StyleAnalyticsAggregate {
  id           String       @id @default(uuid())
  subspecialty Subspecialty
  period       String // e.g., "2024-W01" (weekly)

  // Aggregated patterns (no PHI, no clinician IDs)
  commonAdditions      Json // Frequently added sections/phrases
  commonDeletions      Json // Frequently deleted content
  sectionOrderPatterns Json // Common section arrangements
  phrasingPatterns     Json // High-frequency phrase patterns
  sampleSize           Int // Number of letters contributing

  createdAt DateTime @default(now())

  @@unique([subspecialty, period])
  @@map("style_analytics_aggregates")
}

// ============ Medical Specialties Taxonomy ============

// Global medical specialties (seeded from ABMS, AHPRA, etc.)
model MedicalSpecialty {
  id          String   @id @default(uuid())
  name        String   @unique // e.g., "Cardiology"
  slug        String   @unique // e.g., "cardiology"
  description String?  @db.Text
  synonyms    Json     @default("[]") // e.g., ["cardiologist", "cardiac medicine"]
  active      Boolean  @default(true)
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  // Relations
  subspecialties       MedicalSubspecialty[]
  clinicianSpecialties ClinicianSpecialty[]
  customSubspecialties CustomSubspecialty[]

  @@index([active])
  @@map("medical_specialties")
}

// Subspecialties within a medical specialty
model MedicalSubspecialty {
  id          String           @id @default(uuid())
  specialtyId String           @map("specialty_id")
  specialty   MedicalSpecialty @relation(fields: [specialtyId], references: [id], onDelete: Cascade)
  name        String // e.g., "Interventional cardiology"
  slug        String // e.g., "interventional-cardiology"
  description String?          @db.Text
  active      Boolean          @default(true)
  createdAt   DateTime         @default(now()) @map("created_at")
  updatedAt   DateTime         @updatedAt @map("updated_at")

  // Relations
  clinicianSubspecialties ClinicianSubspecialty[]

  @@unique([specialtyId, slug])
  @@index([specialtyId])
  @@index([active])
  @@map("medical_subspecialties")
}

// Junction table: User's selected specialties
model ClinicianSpecialty {
  id          String           @id @default(uuid())
  userId      String           @map("user_id")
  user        User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  specialtyId String           @map("specialty_id")
  specialty   MedicalSpecialty @relation(fields: [specialtyId], references: [id], onDelete: Cascade)
  createdAt   DateTime         @default(now()) @map("created_at")

  @@unique([userId, specialtyId])
  @@index([userId])
  @@index([specialtyId])
  @@map("clinician_specialties")
}

// Junction table: User's selected subspecialties
model ClinicianSubspecialty {
  id             String              @id @default(uuid())
  userId         String              @map("user_id")
  user           User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  subspecialtyId String              @map("subspecialty_id")
  subspecialty   MedicalSubspecialty @relation(fields: [subspecialtyId], references: [id], onDelete: Cascade)
  createdAt      DateTime            @default(now()) @map("created_at")

  @@unique([userId, subspecialtyId])
  @@index([userId])
  @@index([subspecialtyId])
  @@map("clinician_subspecialties")
}

// Custom specialty requests from clinicians (pending admin review)
model CustomSpecialty {
  id        String              @id @default(uuid())
  userId    String              @map("user_id")
  user      User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  name      String
  region    String? // e.g., "AU", "US" for regional specialties
  notes     String?             @db.Text
  status    CustomRequestStatus @default(PENDING)
  createdAt DateTime            @default(now()) @map("created_at")
  updatedAt DateTime            @updatedAt @map("updated_at")

  // If approved, link to the created MedicalSpecialty
  approvedSpecialtyId String?   @map("approved_specialty_id")

  // Custom subspecialties linked to this custom specialty
  customSubspecialties CustomSubspecialty[]

  @@unique([userId, name])
  @@index([userId])
  @@index([status])
  @@map("custom_specialties")
}

// Custom subspecialty requests from clinicians (pending admin review)
model CustomSubspecialty {
  id          String              @id @default(uuid())
  userId      String              @map("user_id")
  user        User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  name        String
  description String?             @db.Text
  status      CustomRequestStatus @default(PENDING)
  createdAt   DateTime            @default(now()) @map("created_at")
  updatedAt   DateTime            @updatedAt @map("updated_at")

  // Can be linked to either a global specialty or a custom specialty
  specialtyId       String?           @map("specialty_id")
  specialty         MedicalSpecialty? @relation(fields: [specialtyId], references: [id], onDelete: SetNull)
  customSpecialtyId String?           @map("custom_specialty_id")
  customSpecialty   CustomSpecialty?  @relation(fields: [customSpecialtyId], references: [id], onDelete: SetNull)

  // If approved, link to the created MedicalSubspecialty
  approvedSubspecialtyId String?      @map("approved_subspecialty_id")

  @@unique([userId, specialtyId, name])
  @@index([userId])
  @@index([specialtyId])
  @@index([customSpecialtyId])
  @@index([status])
  @@map("custom_subspecialties")
}

// ============ Letter Templates ============

// Subspecialty categories for cardiology
enum Subspecialty {
  GENERAL_CARDIOLOGY
  INTERVENTIONAL
  STRUCTURAL
  ELECTROPHYSIOLOGY
  IMAGING
  HEART_FAILURE
  CARDIAC_SURGERY
}

// Template category for grouping
enum TemplateCategory {
  CONSULTATION
  PROCEDURE
  DIAGNOSTIC
  FOLLOW_UP
  DISCHARGE
}

// Letter templates with subspecialty tagging
model LetterTemplate {
  id          String  @id @default(uuid())
  name        String // e.g., "New Patient Consultation"
  description String? // Brief description of when to use
  slug        String  @unique // URL-friendly identifier

  // Categorization
  category       TemplateCategory
  subspecialties Subspecialty[] // Which subspecialties this applies to
  isGeneric      Boolean          @default(false) // Available to all subspecialties

  // Parent template for variants (e.g., "TTE Report" is parent of "Stress Echo Report")
  parentId String?
  parent   LetterTemplate?  @relation("TemplateVariants", fields: [parentId], references: [id])
  variants LetterTemplate[] @relation("TemplateVariants")

  // Template content
  promptTemplate   String   @db.Text // System prompt additions for this template
  sectionOrder     String[] // Default section order for this template
  requiredSections String[] // Sections that must be included
  optionalSections String[] // Sections that can be added

  // Sample/example content for UI preview
  sampleContent String? @db.Text

  // Metadata
  isActive  Boolean  @default(true)
  sortOrder Int      @default(0) // For display ordering
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  letters         Letter[]
  userPreferences UserTemplatePreference[]
  consultations   Consultation[]

  @@index([category])
  @@index([isGeneric])
  @@map("letter_templates")
}

// User preferences for templates (favorites, per-template style overrides)
model UserTemplatePreference {
  id         String         @id @default(uuid())
  userId     String
  user       User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  templateId String
  template   LetterTemplate @relation(fields: [templateId], references: [id], onDelete: Cascade)

  // Preference flags
  isFavorite Boolean @default(false)
  usageCount Int     @default(0) // Track usage for recommendations

  // Per-template style overrides (extends global styleProfile)
  styleOverrides Json @default("{}") // Partial StyleProfile overrides

  // Last used for recency-based recommendations
  lastUsedAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userId, templateId])
  @@index([userId, isFavorite])
  @@map("user_template_preferences")
}

// ============ Consultation Context ============

// Referrer/GP information (reusable across consultations within a practice)
model Referrer {
  id         String   @id @default(uuid())
  practiceId String
  practice   Practice @relation(fields: [practiceId], references: [id])

  name         String // Dr. John Smith
  practiceName String? // Sydney Medical Centre
  email        String?
  phone        String?
  fax          String?
  address      String? @db.Text // Postal address

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  consultations Consultation[]

  @@index([practiceId])
  @@index([practiceId, name])
  @@map("referrers")
}

// CC Recipients for a specific consultation
model CCRecipient {
  id             String       @id @default(uuid())
  consultationId String
  consultation   Consultation @relation(fields: [consultationId], references: [id], onDelete: Cascade)

  name    String
  email   String?
  address String? @db.Text // Postal address

  createdAt DateTime @default(now())

  @@index([consultationId])
  @@map("cc_recipients")
}

// Consultation context - bundles patient, referrer, recording, and selected materials
model Consultation {
  id     String @id @default(uuid())
  userId String
  user   User   @relation(fields: [userId], references: [id])

  // Patient for this consultation
  patientId String?
  patient   Patient? @relation(fields: [patientId], references: [id])

  // Referrer/GP for this consultation
  referrerId String?
  referrer   Referrer? @relation(fields: [referrerId], references: [id])

  // Letter type pre-selection
  templateId String?
  template   LetterTemplate? @relation(fields: [templateId], references: [id])
  letterType LetterType?

  // Selected context materials (IDs of existing letters/documents to use as context)
  selectedLetterIds   String[] @default([])
  selectedDocumentIds String[] @default([])

  // Status tracking
  status ConsultationStatus @default(DRAFT)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  ccRecipients     CCRecipient[]
  recordings       Recording[]
  documents        Document[]         // Documents uploaded during this consultation
  letters          Letter[]           // Generated letters from this consultation
  referralDocument ReferralDocument?  // Uploaded referral that populated context

  @@index([userId, createdAt])
  @@index([patientId])
  @@index([status])
  @@map("consultations")
}

enum ConsultationStatus {
  DRAFT // Context being gathered
  RECORDING // Recording in progress
  PROCESSING // Transcription/processing in progress
  READY // Ready for letter generation
  COMPLETED // Letter generated
}

// ============ Sent Emails (Resend Integration) ============

model SentEmail {
  id                String      @id @default(uuid())
  userId            String
  user              User        @relation(fields: [userId], references: [id])
  letterId          String
  letter            Letter      @relation(fields: [letterId], references: [id])

  // Recipient information
  recipientEmail    String
  recipientName     String
  ccEmails          String[]    @default([])
  subject           String

  // Provider tracking
  providerMessageId String?     // Resend message ID for tracking
  status            String      @default("pending") // pending, sent, delivered, bounced, failed
  errorMessage      String?     // Error message if failed

  // Timestamps
  sentAt            DateTime?   // When email was accepted by provider
  lastEventAt       DateTime?   // Last webhook event timestamp
  createdAt         DateTime    @default(now())
  updatedAt         DateTime    @updatedAt

  // Webhook data (for debugging)
  webhookPayload    String?     @db.Text

  @@index([userId, createdAt])
  @@index([letterId])
  @@index([providerMessageId])
  @@index([status])
  @@map("sent_emails")
}

// ============ Patient Contacts & Letter Sending ============

enum ContactType {
  GP
  REFERRER
  SPECIALIST
  OTHER
}

enum ChannelType {
  EMAIL
  SECURE_MESSAGING
  FAX
  POST
}

enum SendStatus {
  QUEUED
  SENDING
  SENT
  FAILED
  BOUNCED
}

// ============ Referral Documents ============

enum ReferralDocumentStatus {
  UPLOADED        // File stored, awaiting text extraction
  TEXT_EXTRACTED  // Text extracted from PDF
  EXTRACTED       // AI structured extraction complete
  APPLIED         // Data applied to consultation
  FAILED          // Processing failed
}

// Fast extraction status for two-phase processing
enum FastExtractionStatus {
  PENDING     // Not yet started
  PROCESSING  // Currently extracting patient identifiers
  COMPLETE    // Fast extraction successful
  FAILED      // Fast extraction failed
}

// Full extraction status for background processing
enum FullExtractionStatus {
  PENDING     // Not yet started (waiting for fast extraction)
  PROCESSING  // Currently extracting full context
  COMPLETE    // Full extraction successful
  FAILED      // Full extraction failed
}

model ReferralDocument {
  id         String                 @id @default(uuid())
  userId     String
  user       User                   @relation(fields: [userId], references: [id])
  practiceId String
  practice   Practice               @relation(fields: [practiceId], references: [id])

  // Optional links (set after extraction/review)
  patientId      String?
  patient        Patient?      @relation(fields: [patientId], references: [id])
  consultationId String?       @unique
  consultation   Consultation? @relation(fields: [consultationId], references: [id])

  // File storage
  filename  String
  mimeType  String
  sizeBytes Int
  s3Key     String

  // Processing status (legacy single-phase)
  status ReferralDocumentStatus @default(UPLOADED)

  // Extracted content (legacy single-phase)
  contentText   String? @db.Text // Raw text from PDF/TXT
  extractedData Json?            // Structured extraction result

  // === Two-Phase Extraction (Fast + Background) ===

  // Fast extraction - patient identifiers only (<5 seconds)
  fastExtractionStatus      FastExtractionStatus? @default(PENDING) @map("fast_extraction_status")
  fastExtractionData        Json?                 @map("fast_extraction_data") // { name, dob, mrn, confidence }
  fastExtractionStartedAt   DateTime?             @map("fast_extraction_started_at")
  fastExtractionCompletedAt DateTime?             @map("fast_extraction_completed_at")
  fastExtractionError       String?               @map("fast_extraction_error")

  // Full extraction - complete context (background, <60 seconds)
  fullExtractionStatus      FullExtractionStatus? @default(PENDING) @map("full_extraction_status")
  fullExtractionStartedAt   DateTime?             @map("full_extraction_started_at")
  fullExtractionCompletedAt DateTime?             @map("full_extraction_completed_at")
  fullExtractionError       String?               @map("full_extraction_error")

  // Metadata
  processingError String?
  processedAt     DateTime?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@index([userId, createdAt])
  @@index([practiceId])
  @@index([patientId])
  @@index([status])
  @@index([fastExtractionStatus])
  @@index([fullExtractionStatus])
  @@map("referral_documents")
}

// Patient-linked contacts (GP, referrer, specialists, etc.)
model PatientContact {
  id        String  @id @default(uuid())
  patientId String
  patient   Patient @relation(fields: [patientId], references: [id], onDelete: Cascade)

  type         ContactType // GP, REFERRER, SPECIALIST, OTHER
  fullName     String
  organisation String? // Practice name
  role         String? // Specialty/role (free text)

  // Communication channels
  email             String?
  phone             String?
  fax               String?
  address           String?     @db.Text
  secureMessagingId String? // Future: HealthLink/FHIR
  preferredChannel  ChannelType @default(EMAIL)

  // Defaults
  isDefaultForPatient Boolean @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  letterSends LetterSend[]

  @@index([patientId])
  @@index([patientId, type])
  @@map("patient_contacts")
}

// Audit log for letter sends
model LetterSend {
  id       String @id @default(uuid())
  letterId String
  letter   Letter @relation(fields: [letterId], references: [id], onDelete: Cascade)

  // Denormalized patientId for direct audit queries (preserved even if letter deleted via cascade)
  patientId String?
  patient   Patient? @relation(fields: [patientId], references: [id], onDelete: SetNull)

  // Who sent
  senderId String
  sender   User   @relation(fields: [senderId], references: [id])

  // Recipient info
  patientContactId String? // Nullable for one-off recipients
  patientContact   PatientContact? @relation(fields: [patientContactId], references: [id])

  // Denormalized recipient info (for audit even if contact deleted)
  recipientName  String
  recipientEmail String
  recipientType  ContactType?

  // Send details
  channel   ChannelType @default(EMAIL)
  subject   String
  coverNote String?     @db.Text

  // Status tracking
  status       SendStatus @default(QUEUED)
  queuedAt     DateTime   @default(now())
  sentAt       DateTime?
  failedAt     DateTime?
  errorMessage String?

  // Email provider reference
  externalId String? // Provider message ID for tracking

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([letterId])
  @@index([patientId])
  @@index([senderId])
  @@index([status])
  @@map("letter_sends")
}
